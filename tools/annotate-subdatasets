#!/usr/bin/env python

import logging
import os
import subprocess

import requests

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

# GitHub API token for authentication
GITHUB_TOKEN = os.environ["GITHUB_TOKEN"]
ORGANIZATION = "dandisets"

# Set up the headers for the API request
headers = {
    "Authorization": f"token {GITHUB_TOKEN}",
    "Accept": "application/vnd.github.v3+json",
}


# Get the list of repositories in the organization, handling pagination
def get_repos(organization):
    repos = []
    url = f"https://api.github.com/orgs/{organization}/repos"
    while url:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        repos.extend(response.json())
        # Get the next page URL from the response headers, if it exists
        url = response.links.get("next", {}).get("url")
    return repos


# Check if the submodule exists
def submodule_exists(repo_name):
    result = subprocess.run(
        ["git", "config", "-f", ".gitmodules", "--get", f"submodule.{repo_name}.path"],
        capture_output=True,
        text=True,
    )
    return result.returncode == 0


# Update the .gitmodules file using subprocess
def update_gitmodules(repo_name, access_status):
    if submodule_exists(repo_name):
        config_key = f"submodule.{repo_name}.github-access-status"
        config_value = access_status
        subprocess.run(
            ["git", "config", "-f", ".gitmodules", config_key, config_value], check=True
        )
        logging.info(f"Updated .gitmodules for {repo_name}: {access_status}")
    else:
        logging.info(f"Skipping {repo_name}: Submodule does not exist")


def main():
    repos = get_repos(ORGANIZATION)

    for r in repos:
        repo_name = r["name"]
        access_status = "public" if not r["private"] else "private"
        update_gitmodules(repo_name, access_status)


if __name__ == "__main__":
    main()
